<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>早口ガード（言葉/10秒・会場向け・デバッグ付き）</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 16px; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
    .big { font-size: 36px; font-weight: 800; }
    .warn { color: #b00020; }
    .ok { color: #0b6; }
    label { font-weight: 600; }
    input[type="range"] { width: 260px; }
    select { padding: 6px 8px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button.primary { border-color: #333; }
    textarea { width: 100%; height: 140px; }
    .pill { padding: 3px 8px; border-radius: 999px; border: 1px solid #ddd; font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    /* 投影用の赤帯 */
    #overlay {
      position: fixed;
      left: 0; right: 0; top: 0;
      padding: 18px 20px;
      font-size: 28px;
      font-weight: 900;
      letter-spacing: 0.05em;
      text-align: center;
      color: white;
      background: rgba(176, 0, 32, 0.92);
      display: none;
      z-index: 9999;
    }
    #overlay.blink { animation: blink 0.6s step-end infinite; }
    @keyframes blink { 50% { opacity: 0.25; } }

    progress { height: 16px; }
  </style>
</head>
<body>
  <div id="overlay">早口です。ゆっくり。</div>

  <h1>早口ガード（直近10秒の「言葉数」で警告 / 会場向け / デバッグ付き）</h1>

  <div class="card">
    <div class="row">
      <button id="btnStart" class="primary">Start</button>
      <button id="btnStop">Stop</button>
      <button id="btnFS">FullScreen</button>
      <button id="btnWake">Keep Awake: OFF</button>
      <span id="status" class="pill">停止中</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="metric">基準</label>
      <select id="metric">
        <option value="words" selected>言葉（単語）/10秒</option>
        <option value="chars">文字/10秒（頑丈）</option>
      </select>

      <span class="pill">推奨: words（観客に説明しやすい）</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="thr">閾値</label>
      <input id="thr" type="range" min="5" max="60" value="30" />
      <span id="thrVal" class="pill">30</span>
      <span id="thrUnit" class="pill">語/10秒</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="vol">ビープ音量（0.01〜0.50）</label>
      <input id="vol" type="range" min="0.01" max="0.50" step="0.01" value="0.20" />
      <span id="volVal" class="pill">0.20</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label><input id="beepOn" type="checkbox" checked /> ビープ音（会場向け）</label>
      <label><input id="voiceOn" type="checkbox" checked /> 音声で警告（「ゆっくり」）</label>
      <label><input id="bannerOn" type="checkbox" checked /> 画面に赤帯（投影）</label>
      <label><input id="countInterim" type="checkbox" /> 暫定結果も加味（反応早め・誤差増）</label>
    </div>
  </div>

  <div class="card">
    <div>直近10秒のカウント</div>
    <div id="speed" class="big">0</div>
    <div class="row">
      <div id="judge" class="ok">OK</div>
      <span id="metricInfo" class="pill">words: Intl.Segmenter</span>
    </div>
  </div>

  <!-- デバッグ（音声が読めてるかを見える化） -->
  <div class="card">
    <strong>デバッグ（ここを見ると原因がすぐ分かる）</strong>
    <div class="row" style="margin-top:8px;">
      <div>認識状態: <span id="recState" class="pill mono">-</span></div>
      <div>音声イベント: <span id="audioState" class="pill mono">-</span></div>
    </div>
    <div class="row" style="margin-top:8px;">
      <div>音量: <progress id="meter" max="1" value="0" style="width:260px;"></progress>
        <span id="meterVal" class="pill mono">0.00</span>
      </div>
      <div>最終検出: <span id="lastHeard" class="pill mono">-</span></div>
      <div>最終エラー: <span id="lastErr" class="pill mono">-</span></div>
    </div>
    <div style="margin-top:8px;">暫定テキスト: <span id="interimView" class="pill mono">-</span></div>
  </div>

  <div class="card">
    <div class="row" style="justify-content: space-between;">
      <div>
        <strong>認識テキスト（final）</strong>
        <span class="pill">警告はクールダウン付き</span>
      </div>
      <button id="btnClear">Clear</button>
    </div>
    <textarea id="log" readonly></textarea>
  </div>

  <script>
    // ===== Web Speech API 互換チェック =====
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      alert("このブラウザは音声認識（Web Speech API）に対応していません。Chrome/Edgeを使ってください。");
    }

    // ===== UI =====
    const btnStart = document.getElementById("btnStart");
    const btnStop  = document.getElementById("btnStop");
    const btnClear = document.getElementById("btnClear");
    const btnFS    = document.getElementById("btnFS");
    const btnWake  = document.getElementById("btnWake");

    const statusEl = document.getElementById("status");
    const metricSel= document.getElementById("metric");

    const thr      = document.getElementById("thr");
    const thrVal   = document.getElementById("thrVal");
    const thrUnit  = document.getElementById("thrUnit");

    const vol      = document.getElementById("vol");
    const volVal   = document.getElementById("volVal");

    const speedEl  = document.getElementById("speed");
    const judgeEl  = document.getElementById("judge");
    const logEl    = document.getElementById("log");
    const overlay  = document.getElementById("overlay");

    const beepOn   = document.getElementById("beepOn");
    const voiceOn  = document.getElementById("voiceOn");
    const bannerOn = document.getElementById("bannerOn");
    const countInterim = document.getElementById("countInterim");

    const metricInfo = document.getElementById("metricInfo");

    // デバッグ
    const recStateEl   = document.getElementById("recState");
    const audioStateEl = document.getElementById("audioState");
    const meterEl      = document.getElementById("meter");
    const meterValEl   = document.getElementById("meterVal");
    const lastHeardEl  = document.getElementById("lastHeard");
    const lastErrEl    = document.getElementById("lastErr");
    const interimView  = document.getElementById("interimView");

    function nowStr() {
      const d = new Date();
      return d.toLocaleTimeString();
    }
    function setRecState(s){ recStateEl.textContent = s; }
    function setAudioState(s){ audioStateEl.textContent = s; }
    function setErr(s){ lastErrEl.textContent = s; }
    function setHeard(){ lastHeardEl.textContent = nowStr(); }

    thr.addEventListener("input", () => thrVal.textContent = String(thr.value));
    vol.addEventListener("input", () => volVal.textContent = Number(vol.value).toFixed(2));
    btnClear.addEventListener("click", () => { logEl.value = ""; });

    btnFS.addEventListener("click", async () => {
      try { await document.documentElement.requestFullscreen(); } catch (_) {}
    });

    // ===== Wake Lock（画面スリープ防止。HTTPS必須）=====
    let wakeSentinel = null;
    async function enableWakeLock() {
      if (!("wakeLock" in navigator)) {
        alert("Wake Lock 非対応の環境です（機能なしでも動作はします）。");
        return;
      }
      try {
        wakeSentinel = await navigator.wakeLock.request('screen');
        btnWake.textContent = "Keep Awake: ON";
        wakeSentinel.addEventListener('release', () => {
          btnWake.textContent = "Keep Awake: OFF";
        });
      } catch (e) {
        alert("Wake Lock 失敗: " + (e?.message || String(e)));
      }
    }
    async function disableWakeLock() {
      if (wakeSentinel) {
        await wakeSentinel.release();
        wakeSentinel = null;
      }
      btnWake.textContent = "Keep Awake: OFF";
    }
    btnWake.addEventListener("click", async () => {
      if (wakeSentinel) await disableWakeLock();
      else await enableWakeLock();
    });
    document.addEventListener("visibilitychange", async () => {
      // ページ復帰時に必要なら再取得（失効することがある）
      if (document.visibilityState === "visible" && wakeSentinel) {
        await enableWakeLock();
      }
    });

    // ===== 設定 =====
    const WINDOW_MS = 10_000;   // 10秒窓
    const TICK_MS   = 200;

    // 会場向けは連打しない（観客がうるさくなる）
    const BEEP_COOLDOWN_MS  = 2000;
    const VOICE_COOLDOWN_MS = 4500;

    // ===== 状態 =====
    let rec = null;
    let running = false;

    // (timestamp, n) を積む：n は「言葉数 or 文字数」
    let events = [];
    let lastInterimN = 0;
    let lastInterimTime = 0;

    let lastBeepAt = 0;
    let lastVoiceAt = 0;
    let timerId = null;

    // ===== 音声（ビープ） =====
    let audioCtx = null;

    function ensureAudio() {
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    }

    function beepPattern() {
      if (!beepOn.checked) return;
      try {
        ensureAudio();
        const v = Number(vol.value);
        const now = audioCtx.currentTime;

        const comp = audioCtx.createDynamicsCompressor();
        comp.threshold.value = -24;
        comp.knee.value = 20;
        comp.ratio.value = 6;
        comp.attack.value = 0.003;
        comp.release.value = 0.15;

        const g = audioCtx.createGain();
        g.gain.value = v;

        g.connect(comp);
        comp.connect(audioCtx.destination);

        // ピッ・ピッ（2回）
        for (let k = 0; k < 2; k++) {
          const o = audioCtx.createOscillator();
          o.type = "square";
          o.frequency.setValueAtTime(880, now + k * 0.18);
          o.connect(g);
          o.start(now + k * 0.18);
          o.stop(now + k * 0.18 + 0.12);
        }
      } catch (_) {}
    }

    function speakWarning() {
      if (!voiceOn.checked) return;
      if (!("speechSynthesis" in window)) return;
      try { window.speechSynthesis.cancel(); } catch (_) {}

      const u = new SpeechSynthesisUtterance("ゆっくり");
      u.lang = "ja-JP";
      u.rate = 0.95;
      u.pitch = 1.0;
      u.volume = 1.0;
      try { window.speechSynthesis.speak(u); } catch (_) {}
    }

    // ===== 表示系 =====
    function setStatus(text) { statusEl.textContent = text; }

    function setJudge(isWarn) {
      if (isWarn) {
        judgeEl.textContent = "早口警告";
        judgeEl.classList.remove("ok");
        judgeEl.classList.add("warn");
      } else {
        judgeEl.textContent = "OK";
        judgeEl.classList.remove("warn");
        judgeEl.classList.add("ok");
      }
    }

    function setOverlay(isWarn) {
      if (!bannerOn.checked) {
        overlay.style.display = "none";
        overlay.classList.remove("blink");
        return;
      }
      if (isWarn) {
        overlay.style.display = "block";
        overlay.classList.add("blink");
      } else {
        overlay.style.display = "none";
        overlay.classList.remove("blink");
      }
    }

    // ===== カウント関数 =====
    // 文字数（空白・よくある記号を除去）
    function countCharsJP(text) {
      let s = text.replace(/\s+/g, "");
      s = s.replace(/[、。,.!！?？・：:;；'"“”‘’「」『』（）()［］\[\]【】<>＜＞〜~…‥ー\-—＿_]/g, "");
      return s.length;
    }

    // 言葉数（Intl.Segmenter が使えるならそれで単語分割）
    const hasSegmenter = typeof Intl !== "undefined" && typeof Intl.Segmenter === "function";
    const segJA = hasSegmenter ? new Intl.Segmenter("ja", { granularity: "word" }) : null;

    function countWords(text) {
      // まず空白類を正規化
      const t = (text || "").trim();
      if (!t) return 0;

      if (segJA) {
        let n = 0;
        for (const part of segJA.segment(t)) {
          // isWordLike: 単語っぽいセグメントだけ数える
          if (part.isWordLike) n++;
        }
        return n;
      }

      // フォールバック1：スペース区切り（英語や、認識結果にスペースが入る場合）
      const spaced = t.replace(/\s+/g, " ").trim();
      if (spaced.includes(" ")) {
        return spaced.split(" ").filter(Boolean).length;
      }

      // フォールバック2：最後の手段（日本語でSegmenterが無い環境）
      // 文字数をざっくり割る（完全ではないが「動かない」よりマシ）
      return Math.max(1, Math.round(countCharsJP(t) / 2.5));
    }

    function currentMetric() {
      return metricSel.value; // "words" or "chars"
    }

    function countByMetric(text) {
      return currentMetric() === "words" ? countWords(text) : countCharsJP(text);
    }

    function updateMetricUI() {
      if (currentMetric() === "words") {
        // 現実的な上限：60語/10秒
        thr.min = "5";
        thr.max = "60";
        if (Number(thr.value) > 60) thr.value = "30";
        thrUnit.textContent = "語/10秒";
        metricInfo.textContent = hasSegmenter ? "words: Intl.Segmenter" : "words: fallback";
      } else {
        // 文字は余裕を持って200まで（発表として十分）
        thr.min = "20";
        thr.max = "200";
        if (Number(thr.value) < 20 || Number(thr.value) > 200) thr.value = "90";
        thrUnit.textContent = "文字/10秒";
        metricInfo.textContent = "chars: filtered length";
      }
      thrVal.textContent = String(thr.value);
    }

    metricSel.addEventListener("change", updateMetricUI);
    updateMetricUI();

    // ===== 10秒窓合計 =====
    function computeN10s(now) {
      const cutoff = now - WINDOW_MS;
      events = events.filter(e => e.t >= cutoff);

      let sum = 0;
      for (const e of events) sum += e.n;

      if (countInterim.checked) {
        if (lastInterimTime >= cutoff) sum += lastInterimN;
      }
      return sum;
    }

    function tick() {
      const now = Date.now();
      const n10 = computeN10s(now);
      speedEl.textContent = String(n10);

      const threshold = Number(thr.value);
      const warn = n10 >= threshold;

      setJudge(warn);
      setOverlay(warn);

      if (warn) {
        if (now - lastBeepAt >= BEEP_COOLDOWN_MS) {
          lastBeepAt = now;
          beepPattern();
        }
        if (now - lastVoiceAt >= VOICE_COOLDOWN_MS) {
          lastVoiceAt = now;
          speakWarning();
        }
      }
    }

    // ===== マイク音量メーター（getUserMedia）=====
    let micStream = null;
    let analyser = null;
    let meterRafId = null;

    async function startMicMeter() {
      if (micStream) return;

      try {
        ensureAudio();
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        const src = audioCtx.createMediaStreamSource(micStream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        src.connect(analyser);

        const buf = new Uint8Array(analyser.fftSize);

        const loop = () => {
          analyser.getByteTimeDomainData(buf);
          let sum = 0;
          for (let i = 0; i < buf.length; i++) {
            const v = (buf[i] - 128) / 128;
            sum += v * v;
          }
          const rms = Math.sqrt(sum / buf.length);      // 0〜1くらい
          const shown = Math.min(1, rms * 2.5);         // 見やすいように増幅
          meterEl.value = shown;
          meterValEl.textContent = rms.toFixed(2);
          meterRafId = requestAnimationFrame(loop);
        };
        loop();
      } catch (e) {
        setErr("getUserMedia: " + (e?.name || e?.message || String(e)));
      }
    }

    function stopMicMeter() {
      if (meterRafId) cancelAnimationFrame(meterRafId);
      meterRafId = null;
      if (micStream) {
        micStream.getTracks().forEach(t => t.stop());
        micStream = null;
      }
      analyser = null;
      meterEl.value = 0;
      meterValEl.textContent = "0.00";
    }

    // ===== 音声認識 start/stop =====
    function start() {
      if (running) return;

      ensureAudio(); // 音を確実に鳴らせるように起こす

      // リセット
      events = [];
      lastInterimN = 0;
      lastInterimTime = 0;
      lastBeepAt = 0;
      lastVoiceAt = 0;

      setErr("-");
      setRecState("starting...");
      setAudioState("-");
      interimView.textContent = "-";
      lastHeardEl.textContent = "-";
      setOverlay(false);
      setJudge(false);

      startMicMeter(); // ★音量メーター開始（これが動けばマイクは来てる）

      rec = new SpeechRecognition();
      rec.lang = "ja-JP";
      rec.continuous = true;
      rec.interimResults = true;

      rec.onstart = () => {
        running = true;
        setStatus("動作中（マイク入力中）");
        setRecState("listening");
        timerId = setInterval(tick, TICK_MS);
      };

      // 音声イベント（読めてるか判定）
      rec.onaudiostart  = () => setAudioState("audio start");
      rec.onaudioend    = () => setAudioState("audio end");
      rec.onspeechstart = () => setAudioState("speech start");
      rec.onspeechend   = () => setAudioState("speech end");

      rec.onerror = (ev) => {
        setRecState("error");
        setErr(ev?.error || "unknown");
        setStatus("エラー: " + (ev?.error || "unknown"));
      };

      rec.onend = () => {
        setRecState(running ? "ended (restart...)" : "ended");
        // ブラウザが勝手に止めることがあるので、running なら再開を試す
        if (running) {
          try { rec.start(); } catch (_) {}
        } else {
          setStatus("停止中");
        }
      };

      rec.onresult = (event) => {
        const now = Date.now();
        let interimText = "";

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          const text = res[0].transcript || "";

          if (res.isFinal) {
            const n = countByMetric(text);
            if (n > 0) events.push({ t: now, n });

            logEl.value += text.trim() + "\n";
            logEl.scrollTop = logEl.scrollHeight;

            // final が来たら暫定はリセット（重複加算防止）
            lastInterimN = 0;
            lastInterimTime = 0;
            interimView.textContent = "-";

            setHeard();
          } else {
            interimText += text;
          }
        }

        if (interimText) {
          interimView.textContent = interimText.trim();
          lastInterimN = countByMetric(interimText);
          lastInterimTime = now;
          setHeard();
        }
      };

      try {
        rec.start();
      } catch (e) {
        setErr("start failed");
        alert("開始できませんでした。ページ再読み込み後、マイク許可を確認してください。");
      }
    }

    function stop() {
      running = false;
      if (timerId) { clearInterval(timerId); timerId = null; }

      setOverlay(false);
      setJudge(false);
      speedEl.textContent = "0";

      if (rec) {
        try { rec.onend = null; rec.stop(); } catch (_) {}
      }
      stopMicMeter();

      setStatus("停止中");
      setRecState("stopped");
      setAudioState("-");
      interimView.textContent = "-";

      try { window.speechSynthesis.cancel(); } catch (_) {}
    }

    btnStart.addEventListener("click", start);
    btnStop.addEventListener("click", stop);
  </script>
</body>
  </html>
