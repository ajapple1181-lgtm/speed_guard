<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>早口ガード（言葉/10秒・会場向け・デバッグ強化）</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 16px; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
    .big { font-size: 36px; font-weight: 800; }
    .warn { color: #b00020; }
    .ok { color: #0b6; }
    label { font-weight: 600; }
    input[type="range"] { width: 260px; }
    select { padding: 6px 8px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button.primary { border-color: #333; }
    textarea { width: 100%; height: 140px; }
    .pill { padding: 3px 8px; border-radius: 999px; border: 1px solid #ddd; font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    pre { margin: 0; white-space: pre-wrap; word-break: break-word; }

    /* 投影用の赤帯 */
    #overlay {
      position: fixed;
      left: 0; right: 0; top: 0;
      padding: 18px 20px;
      font-size: 28px;
      font-weight: 900;
      letter-spacing: 0.05em;
      text-align: center;
      color: white;
      background: rgba(176, 0, 32, 0.92);
      display: none;
      z-index: 9999;
    }
    #overlay.blink { animation: blink 0.6s step-end infinite; }
    @keyframes blink { 50% { opacity: 0.25; } }

    progress { height: 16px; }
  </style>
</head>
<body>
  <div id="overlay">早口です。ゆっくり。</div>

  <h1>早口ガード（直近10秒の「言葉数」で警告 / 会場向け / デバッグ強化）</h1>

  <div class="card">
    <div class="row">
      <button id="btnStart" class="primary">Start</button>
      <button id="btnStop">Stop</button>
      <button id="btnFS">FullScreen</button>
      <button id="btnWake">Keep Awake: OFF</button>
      <span id="status" class="pill">停止中</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="metric">基準</label>
      <select id="metric">
        <option value="words" selected>言葉（単語）/10秒</option>
        <option value="chars">文字/10秒（頑丈）</option>
      </select>

      <label><input id="mobileMode" type="checkbox" /> モバイル安定モード（推奨）</label>
      <span id="env" class="pill mono">env: -</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="thr">閾値</label>
      <input id="thr" type="range" min="5" max="60" value="30" />
      <span id="thrVal" class="pill">30</span>
      <span id="thrUnit" class="pill">語/10秒</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="vol">ビープ音量（0.01〜0.50）</label>
      <input id="vol" type="range" min="0.01" max="0.50" step="0.01" value="0.20" />
      <span id="volVal" class="pill">0.20</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label><input id="beepOn" type="checkbox" checked /> ビープ音（会場向け）</label>
      <label><input id="voiceOn" type="checkbox" checked /> 音声で警告（「ゆっくり」）</label>
      <label><input id="bannerOn" type="checkbox" checked /> 画面に赤帯（投影）</label>
      <label><input id="countInterim" type="checkbox" /> 暫定結果も加味（反応早め・誤差増）</label>
    </div>
  </div>

  <div class="card">
    <div>直近10秒のカウント</div>
    <div id="speed" class="big">0</div>
    <div class="row">
      <div id="judge" class="ok">OK</div>
      <span id="metricInfo" class="pill">words: -</span>
    </div>
  </div>

  <div class="card">
    <strong>デバッグ（ここで“認識が返ってるか”が分かる）</strong>
    <div class="row" style="margin-top:8px;">
      <div>認識状態: <span id="recState" class="pill mono">-</span></div>
      <div>音声イベント: <span id="audioState" class="pill mono">-</span></div>
    </div>
    <div class="row" style="margin-top:8px;">
      <div>音量: <progress id="meter" max="1" value="0" style="width:260px;"></progress>
        <span id="meterVal" class="pill mono">0.00</span>
      </div>
      <div>最終検出: <span id="lastHeard" class="pill mono">-</span></div>
      <div>最終エラー: <span id="lastErr" class="pill mono">-</span></div>
    </div>
    <div style="margin-top:8px;">暫定テキスト: <span id="interimView" class="pill mono">-</span></div>
  </div>

  <div class="card">
    <div class="row" style="justify-content: space-between;">
      <div><strong>イベントログ（重要）</strong> <span class="pill">result が出ないなら“APIが返してない”</span></div>
      <button id="btnLogClear">Log Clear</button>
    </div>
    <pre id="evtlog" class="mono" style="margin-top:8px; max-height:220px; overflow:auto;"></pre>
  </div>

  <div class="card">
    <div class="row" style="justify-content: space-between;">
      <div><strong>認識テキスト（final）</strong></div>
      <button id="btnClear">Clear</button>
    </div>
    <textarea id="log" readonly></textarea>
  </div>

  <script>
    // ===== 互換チェック =====
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    // ===== UI =====
    const btnStart = document.getElementById("btnStart");
    const btnStop  = document.getElementById("btnStop");
    const btnClear = document.getElementById("btnClear");
    const btnFS    = document.getElementById("btnFS");
    const btnWake  = document.getElementById("btnWake");
    const btnLogClear = document.getElementById("btnLogClear");

    const statusEl = document.getElementById("status");
    const metricSel= document.getElementById("metric");
    const mobileMode = document.getElementById("mobileMode");
    const envEl = document.getElementById("env");

    const thr      = document.getElementById("thr");
    const thrVal   = document.getElementById("thrVal");
    const thrUnit  = document.getElementById("thrUnit");

    const vol      = document.getElementById("vol");
    const volVal   = document.getElementById("volVal");

    const speedEl  = document.getElementById("speed");
    const judgeEl  = document.getElementById("judge");
    const logEl    = document.getElementById("log");
    const overlay  = document.getElementById("overlay");

    const beepOn   = document.getElementById("beepOn");
    const voiceOn  = document.getElementById("voiceOn");
    const bannerOn = document.getElementById("bannerOn");
    const countInterim = document.getElementById("countInterim");

    const metricInfo = document.getElementById("metricInfo");

    // デバッグ
    const recStateEl   = document.getElementById("recState");
    const audioStateEl = document.getElementById("audioState");
    const meterEl      = document.getElementById("meter");
    const meterValEl   = document.getElementById("meterVal");
    const lastHeardEl  = document.getElementById("lastHeard");
    const lastErrEl    = document.getElementById("lastErr");
    const interimView  = document.getElementById("interimView");

    // イベントログ
    const evtlogEl = document.getElementById("evtlog");
    let evtLines = [];
    function ts() {
      const d = new Date();
      return d.toLocaleTimeString();
    }
    function logEvt(msg) {
      evtLines.push(`[${ts()}] ${msg}`);
      if (evtLines.length > 80) evtLines = evtLines.slice(-80);
      evtlogEl.textContent = evtLines.join("\n");
      evtlogEl.scrollTop = evtlogEl.scrollHeight;
    }
    btnLogClear.addEventListener("click", () => { evtLines = []; evtlogEl.textContent = ""; });

    function setRecState(s){ recStateEl.textContent = s; }
    function setAudioState(s){ audioStateEl.textContent = s; }
    function setErr(s){ lastErrEl.textContent = s; }
    function setHeard(){ lastHeardEl.textContent = ts(); }

    thr.addEventListener("input", () => thrVal.textContent = String(thr.value));
    vol.addEventListener("input", () => volVal.textContent = Number(vol.value).toFixed(2));
    btnClear.addEventListener("click", () => { logEl.value = ""; });

    btnFS.addEventListener("click", async () => {
      try { await document.documentElement.requestFullscreen(); } catch (_) {}
    });

    // ===== Wake Lock =====
    let wakeSentinel = null;
    async function enableWakeLock() {
      if (!("wakeLock" in navigator)) { alert("Wake Lock 非対応の環境です。"); return; }
      try {
        wakeSentinel = await navigator.wakeLock.request('screen');
        btnWake.textContent = "Keep Awake: ON";
        wakeSentinel.addEventListener('release', () => btnWake.textContent = "Keep Awake: OFF");
        logEvt("wakeLock: ON");
      } catch (e) { alert("Wake Lock 失敗: " + (e?.message || String(e))); }
    }
    async function disableWakeLock() {
      if (wakeSentinel) { await wakeSentinel.release(); wakeSentinel = null; }
      btnWake.textContent = "Keep Awake: OFF";
      logEvt("wakeLock: OFF");
    }
    btnWake.addEventListener("click", async () => {
      if (wakeSentinel) await disableWakeLock();
      else await enableWakeLock();
    });

    // ===== 設定 =====
    const WINDOW_MS = 10_000;
    const TICK_MS   = 200;
    const BEEP_COOLDOWN_MS  = 2000;
    const VOICE_COOLDOWN_MS = 4500;

    // ===== 状態 =====
    let rec = null;
    let running = false;
    let events = [];
    let lastInterimN = 0;
    let lastInterimTime = 0;
    let lastBeepAt = 0;
    let lastVoiceAt = 0;
    let timerId = null;
    let restarting = false;

    // ===== 音（ビープ） =====
    let audioCtx = null;
    function ensureAudio() {
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    }
    function beepPattern() {
      if (!beepOn.checked) return;
      try {
        ensureAudio();
        const v = Number(vol.value);
        const now = audioCtx.currentTime;

        const g = audioCtx.createGain();
        g.gain.value = v;
        g.connect(audioCtx.destination);

        for (let k = 0; k < 2; k++) {
          const o = audioCtx.createOscillator();
          o.type = "square";
          o.frequency.setValueAtTime(880, now + k * 0.18);
          o.connect(g);
          o.start(now + k * 0.18);
          o.stop(now + k * 0.18 + 0.12);
        }
      } catch (_) {}
    }
    function speakWarning() {
      if (!voiceOn.checked) return;
      if (!("speechSynthesis" in window)) return;
      try { window.speechSynthesis.cancel(); } catch (_) {}
      const u = new SpeechSynthesisUtterance("ゆっくり");
      u.lang = "ja-JP";
      u.rate = 0.95;
      u.volume = 1.0;
      try { window.speechSynthesis.speak(u); } catch (_) {}
    }

    // ===== 表示 =====
    function setStatus(text) { statusEl.textContent = text; }
    function setJudge(isWarn) {
      judgeEl.textContent = isWarn ? "早口警告" : "OK";
      judgeEl.classList.toggle("warn", isWarn);
      judgeEl.classList.toggle("ok", !isWarn);
    }
    function setOverlay(isWarn) {
      if (!bannerOn.checked) {
        overlay.style.display = "none";
        overlay.classList.remove("blink");
        return;
      }
      if (isWarn) {
        overlay.style.display = "block";
        overlay.classList.add("blink");
      } else {
        overlay.style.display = "none";
        overlay.classList.remove("blink");
      }
    }

    // ===== カウント =====
    function countCharsJP(text) {
      let s = (text || "").replace(/\s+/g, "");
      s = s.replace(/[、。,.!！?？・：:;；'"“”‘’「」『』（）()［］\[\]【】<>＜＞〜~…‥ー\-—＿_]/g, "");
      return s.length;
    }

    const hasSegmenter = typeof Intl !== "undefined" && typeof Intl.Segmenter === "function";
    const segJA = hasSegmenter ? new Intl.Segmenter("ja", { granularity: "word" }) : null;

    function countWords(text) {
      const t = (text || "").trim();
      if (!t) return 0;

      if (segJA) {
        let n = 0;
        for (const part of segJA.segment(t)) {
          if (part.isWordLike) n++;
        }
        return n;
      }
      const spaced = t.replace(/\s+/g, " ").trim();
      if (spaced.includes(" ")) return spaced.split(" ").filter(Boolean).length;
      return Math.max(1, Math.round(countCharsJP(t) / 2.5));
    }

    function currentMetric() { return metricSel.value; } // words / chars
    function countByMetric(text) {
      return currentMetric() === "words" ? countWords(text) : countCharsJP(text);
    }

    function updateMetricUI() {
      if (currentMetric() === "words") {
        thr.min = "5"; thr.max = "60"; // ← 現実的上限
        thrUnit.textContent = "語/10秒";
        metricInfo.textContent = hasSegmenter ? "words: Intl.Segmenter" : "words: fallback";
      } else {
        thr.min = "20"; thr.max = "200";
        thrUnit.textContent = "文字/10秒";
        metricInfo.textContent = "chars: filtered length";
      }
      if (Number(thr.value) < Number(thr.min) || Number(thr.value) > Number(thr.max)) {
        thr.value = currentMetric() === "words" ? "30" : "90";
      }
      thrVal.textContent = String(thr.value);
    }
    metricSel.addEventListener("change", updateMetricUI);
    updateMetricUI();

    // ===== マイク音量メーター =====
    let micStream = null;
    let analyser = null;
    let meterRafId = null;

    async function startMicMeter() {
      if (micStream) return;
      try {
        ensureAudio();
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const src = audioCtx.createMediaStreamSource(micStream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        src.connect(analyser);
        const buf = new Uint8Array(analyser.fftSize);

        const loop = () => {
          analyser.getByteTimeDomainData(buf);
          let sum = 0;
          for (let i = 0; i < buf.length; i++) {
            const v = (buf[i] - 128) / 128;
            sum += v * v;
          }
          const rms = Math.sqrt(sum / buf.length);
          const shown = Math.min(1, rms * 2.5);
          meterEl.value = shown;
          meterValEl.textContent = rms.toFixed(2);
          meterRafId = requestAnimationFrame(loop);
        };
        loop();
        logEvt("getUserMedia: OK (meter running)");
      } catch (e) {
        setErr("getUserMedia: " + (e?.name || e?.message || String(e)));
        logEvt("getUserMedia: FAIL");
      }
    }

    function stopMicMeter() {
      if (meterRafId) cancelAnimationFrame(meterRafId);
      meterRafId = null;
      if (micStream) {
        micStream.getTracks().forEach(t => t.stop());
        micStream = null;
      }
      analyser = null;
      meterEl.value = 0;
      meterValEl.textContent = "0.00";
    }

    // ===== 10秒窓合計 =====
    function computeN10s(now) {
      const cutoff = now - WINDOW_MS;
      events = events.filter(e => e.t >= cutoff);
      let sum = 0;
      for (const e of events) sum += e.n;
      if (countInterim.checked && lastInterimTime >= cutoff) sum += lastInterimN;
      return sum;
    }

    function tick() {
      const now = Date.now();
      const n10 = computeN10s(now);
      speedEl.textContent = String(n10);

      const threshold = Number(thr.value);
      const warn = n10 >= threshold;

      setJudge(warn);
      setOverlay(warn);

      if (warn) {
        if (now - lastBeepAt >= BEEP_COOLDOWN_MS) { lastBeepAt = now; beepPattern(); }
        if (now - lastVoiceAt >= VOICE_COOLDOWN_MS) { lastVoiceAt = now; speakWarning(); }
      }
    }

    function detectEnv() {
      const ua = navigator.userAgent || "";
      const isMobile = /Android|iPhone|iPad|iPod/i.test(ua);
      envEl.textContent = `env: ${isMobile ? "mobile" : "desktop"}`;
      // モバイルは安定モードをデフォルトON
      mobileMode.checked = isMobile;
      logEvt(`UA: ${ua}`);
    }
    detectEnv();

    // ===== 音声認識（再起動管理）=====
    function scheduleRestart(reason) {
      if (!running || restarting) return;
      restarting = true;
      logEvt(`restart scheduled (${reason})`);
      setTimeout(() => {
        restarting = false;
        if (!running) return;
        try { rec.start(); logEvt("rec.start()"); } catch (e) { logEvt("rec.start() failed"); }
      }, 350);
    }

    function startRecognition() {
      if (!SpeechRecognition) {
        alert("SpeechRecognition 非対応です。PCのChrome/Edgeで試すのが確実です。");
        return;
      }

      rec = new SpeechRecognition();
      rec.lang = "ja-JP";
      // ★モバイルは continuous が不安定なので、安定モードなら false にして自動再起動で回す
      rec.continuous = !mobileMode.checked;
      rec.interimResults = true;
      rec.maxAlternatives = 1;

      rec.onstart = () => {
        setRecState("listening");
        setStatus("動作中（マイク入力中）");
        logEvt(`start (continuous=${rec.continuous})`);
      };

      rec.onaudiostart  = () => { setAudioState("audiostart"); logEvt("audiostart"); };
      rec.onaudioend    = () => { setAudioState("audioend"); logEvt("audioend"); };
      rec.onspeechstart = () => { setAudioState("speechstart"); logEvt("speechstart"); };
      rec.onspeechend   = () => { setAudioState("speechend"); logEvt("speechend"); };

      rec.onerror = (ev) => {
        const e = ev?.error || "unknown";
        setErr(e);
        setRecState("error");
        logEvt(`error: ${e}`);

        // よくある：no-speech / aborted は再起動で復帰することがある
        if (e === "no-speech" || e === "aborted") scheduleRestart(e);
        // network は“通信が必要”なので、ネット接続を疑う
        // not-allowed は権限
      };

      rec.onend = () => {
        setRecState(running ? "ended (restart...)" : "ended");
        logEvt("end");
        // 安定モード（continuous=false）なら常に再起動
        if (running) scheduleRestart("end");
      };

      rec.onresult = (event) => {
        logEvt("result");
        const now = Date.now();
        let interimText = "";

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const res = event.results[i];
          const text = res[0]?.transcript || "";

          if (res.isFinal) {
            const n = countByMetric(text);
            if (n > 0) events.push({ t: now, n });
            logEl.value += text.trim() + "\n";
            logEl.scrollTop = logEl.scrollHeight;

            lastInterimN = 0;
            lastInterimTime = 0;
            interimView.textContent = "-";
            setHeard();
          } else {
            interimText += text;
          }
        }

        if (interimText) {
          interimView.textContent = interimText.trim();
          lastInterimN = countByMetric(interimText);
          lastInterimTime = now;
          setHeard();
        }
      };

      try { rec.start(); logEvt("rec.start()"); }
      catch (e) { setErr("start failed"); logEvt("rec.start() failed"); }
    }

    function start() {
      if (running) return;
      ensureAudio();

      // reset
      events = [];
      lastInterimN = 0;
      lastInterimTime = 0;
      lastBeepAt = 0;
      lastVoiceAt = 0;
      restarting = false;

      setErr("-");
      setRecState("starting...");
      setAudioState("-");
      interimView.textContent = "-";
      lastHeardEl.textContent = "-";
      setOverlay(false);
      setJudge(false);
      setStatus("起動中...");

      startMicMeter();
      running = true;
      timerId = setInterval(tick, TICK_MS);

      startRecognition();
    }

    function stop() {
      running = false;
      if (timerId) { clearInterval(timerId); timerId = null; }
      setOverlay(false);
      setJudge(false);
      speedEl.textContent = "0";

      try { if (rec) { rec.onend = null; rec.stop(); } } catch (_) {}
      stopMicMeter();

      setStatus("停止中");
      setRecState("stopped");
      setAudioState("-");
      interimView.textContent = "-";
      try { window.speechSynthesis.cancel(); } catch (_) {}
      logEvt("STOP");
    }

    btnStart.addEventListener("click", start);
    btnStop.addEventListener("click", stop);
  </script>
</body>
  </html>
