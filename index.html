<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>早口検出器</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 16px; }
    h1 { margin: 0 0 10px; font-size: 22px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
    .big { font-size: 36px; font-weight: 800; }
    .warn { color: #b00020; }
    .ok { color: #0b6; }
    label { font-weight: 700; }
    input[type="range"] { width: 260px; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button.primary { border-color: #333; }
    .pill { padding: 3px 8px; border-radius: 999px; border: 1px solid #ddd; font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    #overlay {
      position: fixed; left: 0; right: 0; top: 0;
      padding: 18px 20px;
      font-size: 28px; font-weight: 900; letter-spacing: 0.04em;
      text-align: center; color: #fff;
      background: rgba(176, 0, 32, 0.92);
      display: none; z-index: 9999;
    }
    #overlay.blink { animation: blink 0.6s step-end infinite; }
    @keyframes blink { 50% { opacity: 0.25; } }

    progress { height: 16px; }

    .liveBox {
      border: 1px solid #ddd; border-radius: 12px; padding: 12px;
      min-height: 64px;
      font-size: 20px; line-height: 1.45;
      background: #fafafa;
      word-break: break-word;
    }
  </style>
</head>

<body>
  <div id="overlay">早口です　スピードを落として</div>

  <h1>早口検出器</h1>

  <div class="card">
    <div class="row">
      <button id="btnStart" class="primary">Start</button>
      <button id="btnStop">Stop</button>
      <button id="btnFS">FullScreen</button>
      <span id="status" class="pill">停止中</span>
    </div>

    <div class="row" style="margin-top:12px;">
      <label for="thr">閾値</label>
      <input id="thr" type="range" min="10" max="60" value="40" />
      <span id="thrVal" class="pill">40</span>
      <span class="pill">文字/10秒</span>
    </div>

    <div class="row" style="margin-top:12px;">
      <label for="vol">ビープ音量</label>
      <input id="vol" type="range" min="0.01" max="0.50" step="0.01" value="0.20" />
      <span id="volVal" class="pill">0.20</span>
    </div>

    <div class="row" style="margin-top:12px;">
      <label><input id="beepOn" type="checkbox" checked /> ビープ音</label>
      <label><input id="voiceOn" type="checkbox" checked /> 音声</label>
      <label><input id="bannerOn" type="checkbox" checked /> 赤帯</label>
    </div>
  </div>

  <div class="card">
    <div>直近10秒の文字数</div>
    <div id="speed" class="big">0</div>
    <div class="row">
      <div id="judge" class="ok">OK</div>
      <span class="pill">暫定結果を常に加味</span>
      <span class="pill">モバイル安定モード常時</span>
    </div>
  </div>

  <div class="card">
    <div><strong>ライブ表示</strong></div>
    <div id="live" class="liveBox" style="margin-top:10px;">まだ認識なし</div>
  </div>

  <div class="card">
    <div class="row" style="gap:18px;">
      <div>認識状態 <span id="recState" class="pill mono">-</span></div>
      <div>音声イベント <span id="audioState" class="pill mono">-</span></div>
      <div>最終検出 <span id="lastHeard" class="pill mono">-</span></div>
      <div>最終エラー <span id="lastErr" class="pill mono">-</span></div>
    </div>
    <div class="row" style="margin-top:10px;">
      <div>音量</div>
      <progress id="meter" max="1" value="0" style="width:260px;"></progress>
      <span id="meterVal" class="pill mono">0.00</span>
    </div>
  </div>

<script>
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

  // UI
  const btnStart = document.getElementById("btnStart");
  const btnStop  = document.getElementById("btnStop");
  const btnFS    = document.getElementById("btnFS");

  const statusEl = document.getElementById("status");
  const thr = document.getElementById("thr");
  const thrVal = document.getElementById("thrVal");
  const vol = document.getElementById("vol");
  const volVal = document.getElementById("volVal");

  const speedEl = document.getElementById("speed");
  const judgeEl = document.getElementById("judge");
  const overlay = document.getElementById("overlay");
  const liveEl  = document.getElementById("live");

  const beepOn  = document.getElementById("beepOn");
  const voiceOn = document.getElementById("voiceOn");
  const bannerOn= document.getElementById("bannerOn");

  const recStateEl   = document.getElementById("recState");
  const audioStateEl = document.getElementById("audioState");
  const lastHeardEl  = document.getElementById("lastHeard");
  const lastErrEl    = document.getElementById("lastErr");

  const meterEl = document.getElementById("meter");
  const meterValEl = document.getElementById("meterVal");

  function ts() { return new Date().toLocaleTimeString(); }
  function setStatus(s){ statusEl.textContent = s; }
  function setRecState(s){ recStateEl.textContent = s; }
  function setAudioState(s){ audioStateEl.textContent = s; }
  function setErr(s){ lastErrEl.textContent = s; }
  function setHeard(){ lastHeardEl.textContent = ts(); }

  thr.addEventListener("input", () => thrVal.textContent = String(thr.value));
  vol.addEventListener("input", () => volVal.textContent = Number(vol.value).toFixed(2));
  thrVal.textContent = thr.value;
  volVal.textContent = Number(vol.value).toFixed(2);

  btnFS.addEventListener("click", async () => {
    try { await document.documentElement.requestFullscreen(); } catch (_) {}
  });

  // 常時モバイル安定モード
  // continuous=false で区切りやすくし、onend で作り直して回す
  const WINDOW_MS = 10_000;
  const TICK_MS = 200;
  const BEEP_COOLDOWN_MS = 2000;
  const VOICE_COOLDOWN_MS = 4500;

  let running = false;
  let timerId = null;

  // 10秒窓（final）イベント
  let events = [];
  // 暫定（interim）は常に加味
  let lastInterimN = 0;
  let lastInterimTime = 0;

  let lastBeepAt = 0;
  let lastVoiceAt = 0;

  // 認識
  let rec = null;
  let restartTimer = null;
  let restartDelay = 350;

  // Keep Awake 常時ON（Start時に自動取得）
  let wakeSentinel = null;

  async function enableWakeLockAuto() {
    if (!("wakeLock" in navigator)) return;
    try {
      wakeSentinel = await navigator.wakeLock.request("screen");
    } catch (_) {
      // 失敗しても致命ではない
    }
  }

  document.addEventListener("visibilitychange", async () => {
    if (document.visibilityState === "visible" && running) {
      await enableWakeLockAuto();
    }
  });

  // ビープ
  let audioCtx = null;
  function ensureAudio() {
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
  }

  function beepPattern() {
    if (!beepOn.checked) return;
    try {
      ensureAudio();
      const v = Number(vol.value);
      const now = audioCtx.currentTime;

      const g = audioCtx.createGain();
      g.gain.value = v;
      g.connect(audioCtx.destination);

      for (let k = 0; k < 2; k++) {
        const o = audioCtx.createOscillator();
        o.type = "square";
        o.frequency.setValueAtTime(880, now + k * 0.18);
        o.connect(g);
        o.start(now + k * 0.18);
        o.stop(now + k * 0.18 + 0.12);
      }
    } catch (_) {}
  }

  // 音声
function speakWarning() {
  if (!voiceOn.checked) return;
  if (!("speechSynthesis" in window)) return;

  try { window.speechSynthesis.cancel(); } catch(_) {}

  const u = new SpeechSynthesisUtterance("早口を検出しました");
  u.lang = "ja-JP";
  u.rate = 1.0;
  u.pitch = 1.0;
  u.volume = 1.0;

  try { window.speechSynthesis.speak(u); } catch(_) {}
}

  function setJudge(warn) {
    judgeEl.textContent = warn ? "警告" : "OK";
    judgeEl.classList.toggle("warn", warn);
    judgeEl.classList.toggle("ok", !warn);
  }

  function setOverlay(warn) {
    if (!bannerOn.checked) {
      overlay.style.display = "none";
      overlay.classList.remove("blink");
      return;
    }
    if (warn) {
      overlay.style.display = "block";
      overlay.classList.add("blink");
    } else {
      overlay.style.display = "none";
      overlay.classList.remove("blink");
    }
  }

  // 文字数
  function countCharsJP(text) {
    let s = (text || "").replace(/\s+/g, "");
    s = s.replace(/[、。,.!！?？・：:;；'"“”‘’「」『』（）()［］\[\]【】<>＜＞〜~…‥ー\-—＿_]/g, "");
    return s.length;
  }

  function computeChars10s(now) {
    const cutoff = now - WINDOW_MS;
    events = events.filter(e => e.t >= cutoff);

    let sum = 0;
    for (const e of events) sum += e.n;

    // 暫定結果は常時加味
    if (lastInterimTime >= cutoff) sum += lastInterimN;

    return sum;
  }

  function tick() {
    const now = Date.now();
    const c10 = computeChars10s(now);
    speedEl.textContent = String(c10);

    const warn = c10 >= Number(thr.value);
    setJudge(warn);
    setOverlay(warn);

    if (warn) {
      if (now - lastBeepAt >= BEEP_COOLDOWN_MS) {
        lastBeepAt = now;
        beepPattern();
      }
      if (now - lastVoiceAt >= VOICE_COOLDOWN_MS) {
        lastVoiceAt = now;
        speakWarning();
      }
    }
  }

  // マイク音量メーター
  let micStream = null;
  let analyser = null;
  let meterRafId = null;

  async function startMicMeter() {
    if (micStream) return;
    try {
      ensureAudio();
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const src = audioCtx.createMediaStreamSource(micStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      src.connect(analyser);
      const buf = new Uint8Array(analyser.fftSize);

      const loop = () => {
        analyser.getByteTimeDomainData(buf);
        let sum = 0;
        for (let i = 0; i < buf.length; i++) {
          const v = (buf[i] - 128) / 128;
          sum += v * v;
        }
        const rms = Math.sqrt(sum / buf.length);
        meterEl.value = Math.min(1, rms * 2.5);
        meterValEl.textContent = rms.toFixed(2);
        meterRafId = requestAnimationFrame(loop);
      };
      loop();
    } catch (e) {
      setErr("getUserMedia");
    }
  }

  function stopMicMeter() {
    if (meterRafId) cancelAnimationFrame(meterRafId);
    meterRafId = null;
    if (micStream) {
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
    analyser = null;
    meterEl.value = 0;
    meterValEl.textContent = "0.00";
  }

  function clearRestart() {
    if (restartTimer) clearTimeout(restartTimer);
    restartTimer = null;
  }

  function stopRecognitionInstance() {
    if (!rec) return;
    try { rec.onend = null; rec.stop(); } catch (_) {}
    rec = null;
  }

  function scheduleRecreate(reason) {
    if (!running) return;
    clearRestart();
    restartTimer = setTimeout(() => {
      if (!running) return;
      recreateRecognition(reason);
      restartDelay = Math.min(2000, Math.floor(restartDelay * 1.35));
    }, restartDelay);
  }

  function recreateRecognition(from) {
    if (!SpeechRecognition) {
      setStatus("非対応");
      setErr("unsupported");
      return;
    }

    stopRecognitionInstance();

    rec = new SpeechRecognition();
    rec.lang = "ja-JP";
    rec.interimResults = true;
    rec.maxAlternatives = 1;
    rec.continuous = false;

    rec.onstart = () => {
      setRecState("listening");
      setStatus("動作中");
      setErr("-");
      restartDelay = 350;
    };

    rec.onaudiostart  = () => setAudioState("audiostart");
    rec.onaudioend    = () => setAudioState("audioend");
    rec.onspeechstart = () => setAudioState("speechstart");
    rec.onspeechend   = () => setAudioState("speechend");

    rec.onerror = (ev) => {
      const e = ev?.error || "unknown";
      setErr(e);
      setRecState("error");

      if (e === "not-allowed" || e === "service-not-allowed") {
        setStatus("マイク許可が必要");
        running = false;
        return;
      }
      scheduleRecreate(e);
    };

    rec.onend = () => {
      setRecState(running ? "ended" : "stopped");
      if (running) scheduleRecreate("end");
    };

    rec.onresult = (event) => {
      setHeard();

      const now = Date.now();
      let interimText = "";
      let finalText = "";

      for (let i = event.resultIndex; i < event.results.length; i++) {
        const res = event.results[i];
        const t = res[0]?.transcript || "";
        if (res.isFinal) finalText += t;
        else interimText += t;
      }

      // ライブ表示は常に暫定優先
      if (interimText) {
        const it = interimText.trim();
        liveEl.textContent = it || "認識中";
        lastInterimN = countCharsJP(it);
        lastInterimTime = now;
      }

      if (finalText) {
        const ft = finalText.trim();
        if (ft) {
          liveEl.textContent = ft;
          const n = countCharsJP(ft);
          if (n > 0) events.push({ t: now, n });
          lastInterimN = 0;
          lastInterimTime = 0;
        }
      }
    };

    try {
      rec.start();
    } catch (_) {
      setErr("start failed");
      scheduleRecreate("start-failed");
    }
  }

  async function startAll() {
    if (running) return;

    ensureAudio();
    await enableWakeLockAuto();

    // reset
    events = [];
    lastInterimN = 0;
    lastInterimTime = 0;
    lastBeepAt = 0;
    lastVoiceAt = 0;
    restartDelay = 350;
    clearRestart();

    setStatus("起動中");
    setRecState("starting");
    setAudioState("-");
    setErr("-");
    lastHeardEl.textContent = "-";
    liveEl.textContent = "認識待ち";
    setOverlay(false);
    setJudge(false);

    await startMicMeter();

    running = true;
    timerId = setInterval(tick, TICK_MS);

    recreateRecognition("start");
  }

  function stopAll() {
    running = false;
    clearRestart();

    if (timerId) { clearInterval(timerId); timerId = null; }

    stopRecognitionInstance();
    stopMicMeter();

    setStatus("停止中");
    setRecState("stopped");
    setAudioState("-");
    setErr("-");
    liveEl.textContent = "停止中";
    speedEl.textContent = "0";
    setOverlay(false);
    setJudge(false);

    try { window.speechSynthesis.cancel(); } catch(_) {}
  }

  btnStart.addEventListener("click", startAll);
  btnStop.addEventListener("click", stopAll);

  if (!SpeechRecognition) {
    setStatus("非対応");
    setErr("unsupported");
  }
</script>
</body>
  </html>
